

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/favicon.png">
  <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Hsueh">
  <meta name="keywords" content="">
  <title>面试 - Hsueh&#39; blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.hsueh.club","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"d41ced546e0d98131079f76f87dd8046","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hsueh's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="面试">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Hsueh
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-25 19:15" pubdate>
        星期四, 三月 25日 2021, 7:15 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      233
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：星期六, 四月 24日 2021, 5:35 下午
                
              </p>
            
            <div class="markdown-body">
              <p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">一文搞定 UDP 和 TCP 高频面试题！</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338390842">C++ STL ：Vector内存分配与释放</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/80611486">Mysql锁机制简单了解一下</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ityouknow.com/it/2019/05/11/cookie-session.html">你真的了解 Cookie 和 Session 吗</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/576dbf44b2ae">JWT</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117476959">MySQL事务隔离级别和实现原理</a></p>
<h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1>
<h2 id="tcpudp区别"><a class="markdownIt-Anchor" href="#tcpudp区别"></a> TCP/UDP区别</h2>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br />
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">一文搞定 UDP 和 TCP 高频面试题！</a></p>
<h2 id="tcp三次握手和四次挥手"><a class="markdownIt-Anchor" href="#tcp三次握手和四次挥手"></a> TCP三次握手和四次挥手</h2>
<h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3>
<p>第一次：客户端发送初始序号<code>x</code>和<code>syn=1</code>请求标志</p>
<p>第二次：服务器发送请求标志<code>syn</code>，发送确认标志<code>ACK</code>，发送自己的序号<code>seq=y</code>，发送客户端的确认序号<code>ack=x+1</code></p>
<p>第三次：客户端发送<code>ACK</code>确认号，发送自己的序号<code>seq=x+1</code>，发送对方的确认号<code>ack=y+1</code></p>
<h3 id="三次握手过程分析"><a class="markdownIt-Anchor" href="#三次握手过程分析"></a> 三次握手过程分析</h3>
<p>第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。<code>SYN=1,seq=x</code></p>
<p>第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。<code>ACK=1,ack=x+1,SYN=1,seq=y</code></p>
<p>第三次：客户端发给服务器，服务器知道客户端发送，接收正常，自己接收，发送也正常。<code>seq=x+1,ACK=1,ack=y+1</code></p>
<p>第一次用于确认服务器接收正常，第二次用于确认客户端发送、接收正常，第三次用于确认服务端发送正常</p>
<h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3>
<p>第一次挥手：客户端发出释放<code>FIN=1</code>，自己序列号<code>seq=u</code>，进入<code>FIN-WAIT-1</code>状态</p>
<p>第二次挥手：服务器收到客户端的后，发出<code>ACK=1</code>确认标志和客户端的确认号<code>ack=u+1</code>，自己的序列号<code>seq=v</code>，进入<code>CLOSE-WAIT</code>状态</p>
<p>第三次挥手：客户端收到服务器确认结果后，进入<code>FIN-WAIT-2</code>状态。此时服务器发送释放<code>FIN=1</code>信号，确认标志<code>ACK=1</code>，确认序号<code>ack=u+1</code>，自己序号<code>seq=w</code>，服务器进入<code>LAST-ACK</code>（最后确认态）</p>
<p>第四次挥手：客户端收到回复后，发送确认<code>ACK=1</code>，<code>ack=w+1</code>，自己的<code>seq=u+1</code>，客户端进入<code>TIME-WAIT</code>（时间等待）。客户端经过<code>2</code>个最长报文段寿命后，客户端<code>CLOSE</code>；服务器收到确认后，立刻进入<code>CLOSE</code>状态。</p>
<h3 id="四次挥手过程分析"><a class="markdownIt-Anchor" href="#四次挥手过程分析"></a> 四次挥手过程分析</h3>
<p>第一次：客户端请求断开<code>FIN,seq=u</code></p>
<p>第二次：服务器确认客户端的断开请求<code>ACK</code>,<code>ack=u+1</code>,<code>seq=v</code></p>
<p>第三次：服务器请求断开<code>FIN</code>,<code>seq=w</code>,<code>ACK</code>,<code>ack=u+1</code></p>
<p>第四次：客户端确认服务器的断开<code>ACK</code>,<code>ack=w+1</code>,<code>seq=u+1</code></p>
<h2 id="osi七层模型"><a class="markdownIt-Anchor" href="#osi七层模型"></a> OSI七层模型</h2>
<p>第一层：物理层</p>
<p>第二层：数据链路层</p>
<p>第三层：网络层</p>
<p>第四层：传输层</p>
<p>第五层：会话层</p>
<p>第六层：表示层</p>
<p>第七层：应用层</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/1.jpg" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="1" /></p>
<h2 id="tcpip模型"><a class="markdownIt-Anchor" href="#tcpip模型"></a> TCP/IP模型</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/2.png" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="2" /></p>
<h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3>
<p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。</p>
<h3 id="运输层"><a class="markdownIt-Anchor" href="#运输层"></a> 运输层</h3>
<p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3>
<p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。</p>
<h3 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h3>
<p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3>
<p>在物理层上所传送的数据单位是比特。</p>
<p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h2 id="tcpudp-协议的区别"><a class="markdownIt-Anchor" href="#tcpudp-协议的区别"></a> TCP,UDP 协议的区别</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/3.jfif" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="3" /></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="tcp-协议如何保证可靠传输"><a class="markdownIt-Anchor" href="#tcp-协议如何保证可靠传输"></a> TCP 协议如何保证可靠传输</h2>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="网址中输入url会发生什么"><a class="markdownIt-Anchor" href="#网址中输入url会发生什么"></a> 网址中输入url会发生什么</h2>
<ol>
<li>优先去本地hosts文件里寻找是否有域名、IP对应关系，没有就去找DNS服务器，由DNS服务器完成这一过程</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求</li>
<li>服务器返回响应结果</li>
<li>关闭TCP连接</li>
<li>浏览器解析HTML并渲染<br />
<img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/4.jfif" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="4" /></li>
</ol>
<h2 id="get与post请求的区别post的安全性体现在那里是否可以发现他的请求内容"><a class="markdownIt-Anchor" href="#get与post请求的区别post的安全性体现在那里是否可以发现他的请求内容"></a> get与post请求的区别，post的安全性体现在那里，是否可以发现他的请求内容</h2>
<p>答：区别</p>
<ol>
<li>GET把 <strong>参数包含在URL中</strong>，POST通过request  <strong>body</strong>传递参数</li>
<li>GET请求会被 <strong>浏览器主动cache</strong>，而POST <strong>不会</strong>，除非手动设置。</li>
<li>GET产生 <strong>一个TCP</strong> 数据包；POST产生 <strong>两个T</strong> CP数据包。</li>
<li>GET比POST更不安全，因为参数 <strong>直接暴露在URL上，所以不能用来传递敏感信息</strong>。</li>
<li>GET请求只能进行 <strong>url编码</strong>，而POST支持 <strong>多种编码方式</strong>。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET产生的URL地址可以被 <strong>Bookmark</strong>，而POST不可以</li>
<li><strong>GET在浏览器回退时是无害的，而POST会再次提交请求</strong>。</li>
<li>由于（主流） <strong>浏览器</strong>的一些 <strong>限制</strong>，导致get请求所传输的数据长度和字符编码(ASCII)受到一些限制，但是post请求一般未对其进行限制，所以支持更多的编码和数据长度</li>
</ol>
<p>post的安全性主要体现在上面的2，4，5，6点。可以通过抓包的形式获取到他的请求内容，不过，可能需要进行转码，解密。</p>
<h2 id="http-状态码"><a class="markdownIt-Anchor" href="#http-状态码"></a> HTTP 状态码</h2>
<p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>2XX 成功</p>
<ul>
<li><strong>200 服务器成功返回网页</strong></li>
<li>204 NO CONTENT，请求成功响应，没有资源返回</li>
</ul>
<p>3XX 重定向</p>
<ul>
<li><strong>301 Move permanently 永久性重定向，表示请求的资源已被分配了新的URI</strong>，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</li>
<li><strong>302 found 临时性重定向</strong>，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li>
<li><strong>304 未修改</strong>，<strong>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容，进而节省带宽和开销</strong>。</li>
<li>307 Temporary Redirect 临时的重定向，该响应代码与302重定向有所区别的地方在于，收到307响应码后，客户端应保持请求方法不变向新的地址发出请求</li>
</ul>
<p>4XX 客户端错误</p>
<ul>
<li><strong>400 bad request ，表示请求报文中存在语法错误</strong></li>
<li>403 forbidden ，表明对请求资源的访问被服务器拒绝了</li>
<li>404 not found</li>
<li>405 Method Not Allowed，客户端请求中的方法被禁止</li>
</ul>
<p>5XX 服务器错误</p>
<ul>
<li><strong>500 internal Server error ，表示服务器端在执行请求时发生了错误</strong></li>
<li><strong>502 Bad Gateway</strong>，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个<strong>无效的响应</strong></li>
<li><strong>503 service unavailable ，服务器超时，服务器超负载或正在进行停机维护</strong></li>
<li>504 Gateway Timeout 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应</li>
</ul>
<h2 id="什么是分组交换优缺点"><a class="markdownIt-Anchor" href="#什么是分组交换优缺点"></a> 什么是分组交换？优缺点？</h2>
<p>分组交换采用存储转发技术，把一个<strong>报文</strong>划分为几个<strong>分组</strong>后再进行传送。分组的首部非常重要，包含了<strong>目的地址和源地址</strong>等重要控制信息，这样每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点，最后再组合起来。</p>
<p><strong>优点：</strong></p>
<p>（1）高效，在分组传输时动态分配带宽，对通信链路逐段占用。</p>
<p>（2）灵活，为每一个分组独立地选择最合适的转发路由。</p>
<p>（3）迅速，以分组为单位，可以不先建立连接就能向主机发送数据。</p>
<p>（4）可靠，分布式多路由的分组交换网，使传输鲁棒性强。</p>
<p><strong>缺点：</strong></p>
<p>（1）分组在路由器存储转发时需要排队，有时延。</p>
<p>（2）分组必须携带控制信息（头部）也造成了开销。</p>
<h2 id="请说说http协议的特点"><a class="markdownIt-Anchor" href="#请说说http协议的特点"></a> 请说说HTTP协议的特点</h2>
<ol>
<li>
<p><strong>支持客户/服务器模式</strong></p>
<p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
</li>
<li>
<p><strong>简单快速</strong></p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
</li>
<li>
<p><strong>灵活</strong></p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>
</li>
<li>
<p><strong>无连接</strong></p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
<li>
<p><strong>无状态</strong></p>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。</p>
</li>
</ol>
<h2 id="https的加密原理"><a class="markdownIt-Anchor" href="#https的加密原理"></a> HTTPS的加密原理</h2>
<p>HTTPS采用<strong>对称密钥</strong>加密和<strong>非对称密钥</strong>加密加密两者混合加密，两者都有各自的优点。<strong>对称密钥加密处理速度快，但密钥无法安全发送给对方</strong>；<strong>非对称密钥加密处理速度慢，但密钥能够安全交换</strong>。但如果我们将两种加密方式一起使用，则两种加密方式就能互补。</p>
<p>也就是说，利用<strong>非对称密钥</strong>加密方式安全地交换在稍后的<strong>对称密钥</strong>加密中要使用的密钥，在确保密钥安全前提下，使用<strong>对称密钥</strong>加密方式进行通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/10.png" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="5" /></p>
<h2 id="什么是对称加密什么是非对称加密两者区别"><a class="markdownIt-Anchor" href="#什么是对称加密什么是非对称加密两者区别"></a> 什么是对称加密？什么是非对称加密？两者区别？</h2>
<ol>
<li>
<p><strong>对称密钥加密：加密与解密使用同一个密钥</strong></p>
<p>也就是说在加密的同时，也会把密钥发送给对方。</p>
</li>
<li>
<p><strong>非对称密钥</strong></p>
<p><strong>非对称密钥加密</strong>有两把密钥。一把叫私有密钥，另一把叫公有密钥。私有密钥不让任何人知道，公有密钥随意发送。</p>
</li>
</ol>
<h2 id="对称加密有哪些非对称加密有哪些"><a class="markdownIt-Anchor" href="#对称加密有哪些非对称加密有哪些"></a> 对称加密有哪些？非对称加密有哪些？</h2>
<p>一种是<strong>对称密钥加密</strong>例如：DES、AES-GCM、ChaCha20-Poly1305等，一种是<strong>非对称密钥加密</strong>，例如：RSA、DSA、ECDSA、 DH、ECDHE</p>
<h2 id="数字证书用来干嘛的"><a class="markdownIt-Anchor" href="#数字证书用来干嘛的"></a> 数字证书用来干嘛的？</h2>
<p>服务器会给客户端发出数字证书来证明自己的身份。<strong>客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验</strong>。证书中包含的具体内容有：</p>
<ol>
<li>证书的发布机构CA</li>
<li>证书的有效期</li>
<li>公钥</li>
<li>证书所有者</li>
<li>签名</li>
</ol>
<p>这样我们通过数字证书，就可以安全交换对称秘钥了，<strong>既解决了公钥获取问题，又解决了黑客冒充问题</strong>，一箭双雕。</p>
<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1>
<h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位</p>
<p>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p>
<h3 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h3>
<p>1） 运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。</p>
<p>2） 就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。</p>
<p>3） 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。及时处理器空闲，该进程也不能运行。</p>
<p>4） 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB（process control block），并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。</p>
<p>5） 结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。</p>
<p>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要活得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，及时处理器空闲也不能运行。</p>
<h3 id="进程特征"><a class="markdownIt-Anchor" href="#进程特征"></a> 进程特征</h3>
<p>1） 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周奇奇，是动态的产生、变化和消亡的。动态性是进程最基本的特征。</p>
<p>2） 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与去其他进程的程序并发执行，以提高资源利用率。</p>
<p>3） 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。</p>
<p>4） 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。</p>
<p>5） 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。</p>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>
<p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h3 id="多线程和多进程"><a class="markdownIt-Anchor" href="#多线程和多进程"></a> 多线程和多进程</h3>
<p>多进程：操作系统中同时运行的多个程序</p>
<p>多线程：在同一个进程中同时运行的多个任务</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据是分开的:共享复杂，需要用IPC;同步简单</td>
<td>多线程共享进程数据：共享简单；同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会相互影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>内存管理，单个进程的异常不会导致整个应用的崩溃，方便调试</td>
<td>提高系统并行性，开销小</td>
</tr>
<tr>
<td>缺点</td>
<td>进程间调用，通讯和切换开销均比多线程大</td>
<td>没有内存隔离，单个线程的崩溃会导致整个应用的而退出，定位不方便</td>
</tr>
<tr>
<td>使用场合</td>
<td>目标子功能间交互少，如果资源和性能许可，请设计由多个子应用程序来组合完成你的目标</td>
<td>存在大量IO，网络等耗时操作，或者需要和用户交互时，使用多线程有利于提高系统的并行性和用户界面快速响应从而提高友好型</td>
</tr>
</tbody>
</table>
<ol>
<li>需要频繁创建销毁的优先用线程。<br />
实例：web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。</li>
<li>需要进行大量计算的优先使用线程。<br />
所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。<br />
实例：图像处理、算法处理</li>
<li>强相关的处理用线程，若相关的处理用进程。<br />
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。<br />
一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。</li>
<li>可能扩展到多机分布的用进程，多核分布的用线程。</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式。</li>
</ol>
<h3 id="进程间的通信方式"><a class="markdownIt-Anchor" href="#进程间的通信方式"></a> 进程间的通信方式</h3>
<ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="线程间的同步的方式"><a class="markdownIt-Anchor" href="#线程间的同步的方式"></a> 线程间的同步的方式</h3>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li>
</ol>
<h3 id="进程的调度算法"><a class="markdownIt-Anchor" href="#进程的调度算法"></a> 进程的调度算法</h3>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="虚拟地址空间"><a class="markdownIt-Anchor" href="#虚拟地址空间"></a> 虚拟地址空间</h3>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/5.png" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="5" /></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h3 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h3>
<p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。</p>
<h3 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h3>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h2 id="常见的几种内存管理机制"><a class="markdownIt-Anchor" href="#常见的几种内存管理机制"></a> 常见的几种内存管理机制</h2>
<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<h2 id="内核态与用户态的区别"><a class="markdownIt-Anchor" href="#内核态与用户态的区别"></a> 内核态与用户态的区别</h2>
<ol>
<li><strong>内核态与用户态</strong>：<strong>内核态</strong>（系统态）与<strong>用户态</strong>是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。</li>
<li><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</li>
<li><strong>为什么区分内核态与用户态</strong>：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。</li>
</ol>
<h4 id="虚拟地址到物理地址怎么映射的"><a class="markdownIt-Anchor" href="#虚拟地址到物理地址怎么映射的"></a> 虚拟地址到物理地址怎么映射的？</h4>
<p>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫<strong>页表。页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。</strong></p>
<p><strong>三级页表转换方法：（两步）</strong></p>
<p>（1）逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址</p>
<p>（2）线性地址转物理地址：</p>
<p>每一个32位的线性地址被划分为三部分：页目录索引（10位）、页表索引（10位）、页内偏移（12位）</p>
<ul>
<li>从cr3中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）</li>
<li>页目录地址 + 页目录索引 = 页表地址</li>
<li>页表地址 + 页表索引 = 页地址</li>
<li>页地址 + 页内偏移 = 物理地址</li>
</ul>
<h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1>
<h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2>
<h3 id="什么是事务"><a class="markdownIt-Anchor" href="#什么是事务"></a> 什么是事务?</h3>
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事务的四大特性acid"><a class="markdownIt-Anchor" href="#事务的四大特性acid"></a> 事务的四大特性(ACID)</h3>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<strong>用undo log实现</strong></li>
<li><strong>一致性（Consistency）：</strong> 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来哪些问题"><a class="markdownIt-Anchor" href="#并发事务带来哪些问题"></a> 并发事务带来哪些问题?</h3>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别有哪些mysql的默认隔离级别是"><a class="markdownIt-Anchor" href="#事务隔离级别有哪些mysql的默认隔离级别是"></a> 事务隔离级别有哪些?MySQL的默认隔离级别是?</h3>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<h3 id="第一范式"><a class="markdownIt-Anchor" href="#第一范式"></a> 第一范式</h3>
<p>定义：数据库表中的字段都是单一属性的，不可再分。</p>
<p>简单的说，每一个属性都是原子项，不可分割。</p>
<p>1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。也就是说，只要是关系型数据库，就一定满足第一范式。</p>
<h3 id="第二范式"><a class="markdownIt-Anchor" href="#第二范式"></a> 第二范式</h3>
<p>定义：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，即符合第二范式。</p>
<p>简单的说，一方面，第二范式肯定要满足第一范式，否则就没有必要谈第二范式。</p>
<p>另一方面，当某张表中的非主键信息不是由整个主键函数来决定时，即存在依赖于该表中不是主键的部分或者依赖于主键一部分的部分时，通常会违反<strong>2NF</strong>。</p>
<h3 id="第三范式"><a class="markdownIt-Anchor" href="#第三范式"></a> 第三范式</h3>
<p>定义：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合<strong>3NF</strong>。</p>
<h2 id="乐观锁和悲观锁"><a class="markdownIt-Anchor" href="#乐观锁和悲观锁"></a> 乐观锁和悲观锁</h2>
<p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br />
<strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。<br />
要明确一下：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。<br />
<strong>实现方式</strong>：<br />
悲观锁的实现可以依靠数据库里的锁机制，如排它锁。<br />
乐观锁的实现Compare and Swap(CAS)：当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br />
乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现<strong>ABA问题</strong>，因为版本号只会增加不会减少。除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。<br />
ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。关于ABA问题举一个例子：在你非常渴的情况下你发现一个盛满水的杯子，你一饮而尽。之后再给杯子里重新倒满水。然后你离开，当杯子的真正主人回来时看到杯子还是盛满水，他当然不知道是否被人喝完重新倒满。解决这个问题的方案的一个策略是每一次倒水假设有一个自动记录仪记录下，这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。这也是解决ABA问题目前采用的策略。用<strong>悲观锁</strong>就可以解决这个问题。</p>
<h2 id="b树与b树的区别"><a class="markdownIt-Anchor" href="#b树与b树的区别"></a> B树与B+树的区别</h2>
<ol>
<li>B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。</li>
<li>B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>
<li>B树查找，中途内部节点处可能停止返回，所以B树查找时间复杂度不稳定；B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径，查找时间复杂度稳定。</li>
<li>B+树的叶子节点通过链表相连，所以B+树范围查找比B树效率高。</li>
</ol>
<p><strong>B树和B+树的共同优点</strong><br />
考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树和B+树的特征之一，m的大小取决于磁盘页的大小。</p>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/7.png" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="5" /></p>
<h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2>
<p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NULL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
</ul>
<p>查询时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/96e652ccf720">红黑树插入</a></p>
<h1 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h1>
<h2 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h2>
<p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</p>
<h3 id="auto_ptr"><a class="markdownIt-Anchor" href="#auto_ptr"></a> auto_ptr</h3>
<p>从C ++ 11开始，此类模板已被弃用。 unique_ptr是具有相似功能但具有改进的安全性的新工具。<br />
auto_ptr是一个智能指针，用于管理通过新表达式获取的对象，并在auto_ptr本身被销毁时删除该对象。<br />
当使用auto_ptr类描述一个对象时，它存储一个指向单个分配对象的指针，该对象可以确保当它超出范围时，它指向的对象必须被自动销毁。 它基于独占所有权模式，即同一类型的两个指针不能同时指向相同的资源。 如下面的程序所示，复制或分配指针会更改所有权，即源指针必须赋予目标指针所有权。</p>
<h3 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> unique_ptr</h3>
<p>unique_ptr 是一个独享所有权的智能指针：</p>
<ol>
<li>拥有它指向的对象</li>
<li>无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作</li>
<li>保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象</li>
</ol>
<p>unique_ptr 可以实现如下功能：</p>
<ol>
<li>
<p>为动态申请的内存提供异常安全</p>
</li>
<li>
<p>讲动态申请的内存所有权传递给某函数</p>
</li>
<li>
<p>从某个函数返回动态申请内存的所有权</p>
</li>
<li>
<p>在容器中保存指针</p>
</li>
<li>
<p>auto_ptr 应该具有的功能</p>
</li>
</ol>
<h3 id="shared_ptr"><a class="markdownIt-Anchor" href="#shared_ptr"></a> shared_ptr</h3>
<p>从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。出了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源（指向的对象）会被释放。此处调动reset不能销毁对象，只有当计数为0时候才可以。</p>
<h3 id="week_ptr"><a class="markdownIt-Anchor" href="#week_ptr"></a> week_ptr</h3>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<p>weak_ptr没有重载 * 和 -&gt; ，所以并不能直接使用资源。但可以使用lock()获得一个可用的shared_ptr对象，<br />
如果对象已经死了，lock()会失败，返回一个空的shared_ptr。</p>
<h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2>
<p>vector:底层数据结构为数组 ，支持快速随机访问。</p>
<p>list:底层数据结构为双向链表，支持快速增删。</p>
<p>deque:底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问。</p>
<p>stack:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
<p>queue:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p>
<p>priority_queue:的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p>
<p>set:底层数据结构为红黑树，有序，不重复。</p>
<p>multiset:底层数据结构为红黑树，有序，可重复。</p>
<p>map:底层数据结构为红黑树，有序，不重复。</p>
<p>multimap:底层数据结构为红黑树，有序，可重复。</p>
<p>hash_set:底层数据结构为hash表，无序，不重复。</p>
<p>hash_multiset:底层数据结构为hash表，无序，可重复 。</p>
<p>hash_map :底层数据结构为hash表，无序，不重复。</p>
<p>hash_multimap:底层数据结构为hash表，无序，可重复。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338390842">C++ STL ：Vector内存分配与释放</a></p>
<h2 id="c11特性"><a class="markdownIt-Anchor" href="#c11特性"></a> C++11特性</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21930436">c++11新特性详解</a></p>
<h2 id="说说new和malloc的区别各自底层实现原理"><a class="markdownIt-Anchor" href="#说说new和malloc的区别各自底层实现原理"></a> 说说new和malloc的区别，各自底层实现原理</h2>
<ol>
<li>new是操作符，而malloc是函数。</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li>
<li>new可以被重载；malloc不行</li>
<li>new分配内存更直接和安全。</li>
<li>new发生错误抛出异常，malloc返回null</li>
</ol>
<h2 id="为什么要少使用宏c有什么解决方案"><a class="markdownIt-Anchor" href="#为什么要少使用宏c有什么解决方案"></a> 为什么要少使用宏？C++有什么解决方案？</h2>
<ol>
<li>
<p>由程序编译的四个过程，知道<strong>宏是在预编译阶段被展开的。<strong>在预编译阶段是不会进行</strong>语法检查、语义分析的</strong>，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题。比如在表达式中忘记加括号等问题。</p>
</li>
<li>
<p>正因为如此，在C++中为了安全性，我们就要少用宏。</p>
<p>不带参数的宏命令我们可以用<strong>常量const</strong>来替代，比如<code>const int PI = 3.1415</code>，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。</p>
<p>而带参数的宏命令有点类似函数的功能，在C++中可以使用<strong>内联函数或模板</strong>来替代，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析等，而宏命令发生在预编译阶段，属于暴力替换，并不安全。</p>
</li>
</ol>
<h2 id="说说volatile和mutable"><a class="markdownIt-Anchor" href="#说说volatile和mutable"></a> 说说volatile和mutable</h2>
<p><strong>mutable</strong>是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。</p>
<p>一个定义为<strong>volatile</strong>的变量是说这变量可能会被意想不到地改变，这样，编译器每次会从内存里重新读取这个变量的值，而不是从寄存器里读取。特别是多线程编程中，变量的值在内存中可能已经被修改，而编译器优化优先从寄存器里读值，读取的并不是最新值。这就是volatile的作用了。</p>
<h2 id="请你说说虚函数的工作机制"><a class="markdownIt-Anchor" href="#请你说说虚函数的工作机制"></a> 请你说说虚函数的工作机制</h2>
<p>C++实现虚函数的原理是虚函数表+虚表指针。</p>
<p>当一个类里存在虚函数时，编译器会为类创建一个虚函数表，<strong>虚函数表</strong>是一个<strong>数组</strong>，数组的元素存放的是类中<strong>虚函数的地址</strong>。</p>
<p>同时为每个类的对象添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的指针。该隐藏成员占据该对象的内存布局的最前端。</p>
<p><strong>所以虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针</strong>。</p>
<h3 id="请你说说智能指针智能指针为什么不用手动释放内存了"><a class="markdownIt-Anchor" href="#请你说说智能指针智能指针为什么不用手动释放内存了"></a> 请你说说智能指针，智能指针为什么不用手动释放内存了？</h3>
<p>使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等。</p>
<p>正是因为指针存在这样的问题，C++便引入了智能指针来更好的管理堆内存。智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</p>
<p>因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。这样程序员就不用再担心内存泄露的问题了。</p>
<p>C<ins>里面有四个指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr，后面三个是C</ins>11支持的，第一个被C++11弃用。</p>
<h3 id="auto_ptr有什么样的问题"><a class="markdownIt-Anchor" href="#auto_ptr有什么样的问题"></a> auto_ptr有什么样的问题</h3>
<p>看如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(``<span class="hljs-keyword">new</span>` `<span class="hljs-built_in">string</span> (``<span class="hljs-string">&quot;I am jiang douya.&quot;</span>``))</span></span>;<br><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2; ``p2 = p1; ``<span class="hljs-comment">//auto_ptr不会报错.</span><br></code></pre></div></td></tr></table></figure>
<p><strong>auto</strong>指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，存在潜在的内存崩溃问题！因此<strong>auto</strong>指针被C++11弃用。应该用<strong>unique</strong>指针替代<strong>auto</strong>指针。</p>
<h3 id="unique_ptr指针实现原理"><a class="markdownIt-Anchor" href="#unique_ptr指针实现原理"></a> unique_ptr指针实现原理</h3>
<p><strong>unique指针</strong>规定<strong>一个智能指针独占一块内存资源</strong>。当两个智能指针同时指向一块内存，编译报错。</p>
<p>我们只需要将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符</p>
<h3 id="shared_ptr实现原理来手撕一下"><a class="markdownIt-Anchor" href="#shared_ptr实现原理来手撕一下"></a> shared_ptr实现原理，来手撕一下</h3>
<p>实现原理：有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mysharedPtr</span> &#123;</span>  <br><span class="hljs-keyword">public</span>:  <br>    mysharedPtr(T* p = <span class="hljs-literal">NULL</span>);  <br>    ~mysharedPtr();  <br>    mysharedPtr(<span class="hljs-keyword">const</span> mysharedPtr&lt;T&gt;&amp; other);  <br>    mysharedPtr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> mysharedPtr&lt;T&gt;&amp; other);  <br><span class="hljs-keyword">private</span>:  <br>    T* m_ptr;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>* m_count;  <br>&#125;;  <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br>mysharedPtr&lt;T&gt;::mysharedPtr(T* p) &#123;  <br>    m_ptr = p;  <br>    m_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);  <br>    ++(*m_count);  <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Constructor is succeed!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>&#125;  <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br>mysharedPtr&lt;T&gt;::~mysharedPtr() &#123;  <br>    --(*m_count);  <br>    <span class="hljs-keyword">if</span> ((*m_count) == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">delete</span>[] m_ptr;  <br>        m_ptr = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-keyword">delete</span>[] m_count;  <br>        m_count = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Destructor is succeed!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br>mysharedPtr&lt;T&gt;::mysharedPtr(<span class="hljs-keyword">const</span> mysharedPtr&lt;T&gt;&amp; other) &#123;  <br>    m_ptr = other.m_ptr;  <br>    m_count = other.m_count;  <br>    ++(*m_count);  <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Copy constructor is succeed!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>&#125;  <br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br>mysharedPtr&lt;T&gt;&amp; mysharedPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> mysharedPtr&lt;T&gt;&amp; other) &#123;  <br>    <span class="hljs-comment">// 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使other的使用计数加1，  </span><br>    <span class="hljs-comment">// 从而防止自身赋值”而导致的提早释放内存  </span><br>    ++(*other.m_count);  <br>    --(*m_count);  <br>    <span class="hljs-comment">// 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象  </span><br>    <span class="hljs-keyword">if</span> ((*m_count) == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">delete</span>[] m_ptr;  <br>        m_ptr = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-keyword">delete</span>[] m_count;  <br>        m_count = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Left side object is deleted!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>    &#125;  <br>    m_ptr = other.m_ptr;  <br>    m_count = other.m_count;  <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Assignment operator overloaded is succeed!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <br>&#125;  <br></code></pre></div></td></tr></table></figure>
<h3 id="shared_ptr会不会出现内存泄露怎么解决"><a class="markdownIt-Anchor" href="#shared_ptr会不会出现内存泄露怎么解决"></a> shared_ptr会不会出现内存泄露？怎么解决？</h3>
<p>会出现内存泄露问题。</p>
<p>共享指针的循环引用计数问题：当两个类中相互定义shared_ptr成员变量，同时对象相互赋值时，就会产生循环引用计数问题，最后引用计数无法清零，资源得不到释放。</p>
<p>可以使用weak_ptr，weak_ptr是<strong>弱引用</strong>，weak_ptr的<strong>构造和析构不会引起引用计数的增加或减少</strong>。我们可以将其中一个改为weak_ptr指针就可以了。比如我们将class B里shared_ptr换成weak_ptr。</p>
<h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h1>
<h2 id="java入门"><a class="markdownIt-Anchor" href="#java入门"></a> JAVA入门</h2>
<h3 id="java-语言有哪些特点"><a class="markdownIt-Anchor" href="#java-语言有哪些特点"></a> Java 语言有哪些特点?</h3>
<ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<h3 id="java-程序从源代码到运行一般有下面-3-步"><a class="markdownIt-Anchor" href="#java-程序从源代码到运行一般有下面-3-步"></a> <strong>Java 程序从源代码到运行一般有下面 3 步：</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/upload/interview/6.png" srcset="https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/img/loading.gif" alt="6" /></p>
<h3 id="jdk-和-jre"><a class="markdownIt-Anchor" href="#jdk-和-jre"></a> JDK 和 JRE</h3>
<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="java-和-c的区别"><a class="markdownIt-Anchor" href="#java-和-c的区别"></a> Java 和 C++的区别?</h3>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符<code>'\0'</code>来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li>
</ul>
<h3 id="和-equals-的区别"><a class="markdownIt-Anchor" href="#和-equals-的区别"></a> ==和 equals 的区别</h3>
<p><strong><code>==</code></strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(<strong>基本数据类型<mark>比较的是值，引用数据类型</mark>比较的是内存地址</strong>)</p>
<h3 id="重载和重写的区别"><a class="markdownIt-Anchor" href="#重载和重写的区别"></a> 重载和重写的区别</h3>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h3 id="深拷贝-vs-浅拷贝"><a class="markdownIt-Anchor" href="#深拷贝-vs-浅拷贝"></a> 深拷贝 vs 浅拷贝</h3>
<ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<h3 id="finalstaticthissuper-关键字总结"><a class="markdownIt-Anchor" href="#finalstaticthissuper-关键字总结"></a> final,static,this,super 关键字总结</h3>
<h4 id="final-关键字"><a class="markdownIt-Anchor" href="#final-关键字"></a> final 关键字</h4>
<p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p>
<ol>
<li><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></li>
<li><strong>final修饰的方法不能被重写；</strong></li>
<li><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></li>
</ol>
<h4 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> static 关键字</h4>
<p><strong>static 关键字主要有以下四种使用场景：</strong></p>
<ol>
<li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></li>
<li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>
<li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h4 id="this-关键字"><a class="markdownIt-Anchor" href="#this-关键字"></a> this 关键字</h4>
<p>this关键字用于引用类的当前实例。</p>
<h4 id="super-关键字"><a class="markdownIt-Anchor" href="#super-关键字"></a> super 关键字</h4>
<p>super关键字用于从子类访问父类的变量和方法。</p>
<h2 id="static-关键字详解"><a class="markdownIt-Anchor" href="#static-关键字详解"></a> static 关键字详解</h2>
<h3 id="static-关键字主要有以下四种使用场景"><a class="markdownIt-Anchor" href="#static-关键字主要有以下四种使用场景"></a> static 关键字主要有以下四种使用场景</h3>
<ol>
<li>修饰成员变量和成员方法</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li>
</ol>
<h3 id="修饰成员变量和成员方法常用"><a class="markdownIt-Anchor" href="#修饰成员变量和成员方法常用"></a> 修饰成员变量和成员方法(常用)</h3>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p>
<h3 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h3>
<p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —&gt; 非静态代码块 —&gt; 构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p>
<h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3>
<p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li>它的创建是不需要依赖外围类的创建。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ol>
<h3 id="静态导包"><a class="markdownIt-Anchor" href="#静态导包"></a> 静态导包</h3>
<p>格式为：import static</p>
<p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p>
<h3 id="静态方法与非静态方法"><a class="markdownIt-Anchor" href="#静态方法与非静态方法"></a> 静态方法与非静态方法</h3>
<p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p>
<h3 id="static静态代码块与非静态代码块构造代码块"><a class="markdownIt-Anchor" href="#static静态代码块与非静态代码块构造代码块"></a> <code>static&#123;&#125;</code>静态代码块与<code>&#123;&#125;</code>非静态代码块(构造代码块)</h3>
<p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。</p>
<p>不同点： 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p>
<h2 id="java-面向对象"><a class="markdownIt-Anchor" href="#java-面向对象"></a> Java 面向对象</h2>
<h3 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h3>
<h4 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h4>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<h3 id="面向对象三大特征"><a class="markdownIt-Anchor" href="#面向对象三大特征"></a> 面向对象三大特征</h3>
<h4 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了。</p>
<h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4>
<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h4>
<p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h2 id="java容器"><a class="markdownIt-Anchor" href="#java容器"></a> Java容器</h2>
<h3 id="说说-listsetmap-三者的区别"><a class="markdownIt-Anchor" href="#说说-listsetmap-三者的区别"></a> 说说 List,Set,Map 三者的区别？</h3>
<ul>
<li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，&quot;y&quot;代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="集合框架底层数据结构总结"><a class="markdownIt-Anchor" href="#集合框架底层数据结构总结"></a> 集合框架底层数据结构总结</h3>
<p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h4>
<ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4>
<ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="collection-子接口之-list"><a class="markdownIt-Anchor" href="#collection-子接口之-list"></a> Collection 子接口之 List</h2>
<h3 id="arraylist-和-vector-的区别"><a class="markdownIt-Anchor" href="#arraylist-和-vector-的区别"></a> Arraylist 和 Vector 的区别?</h3>
<ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h3 id="arraylist-与-linkedlist-区别"><a class="markdownIt-Anchor" href="#arraylist-与-linkedlist-区别"></a> Arraylist 与 LinkedList 区别?</h3>
<ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<p>ArrayList扩容为1.5倍</p>
<h2 id="map-接口"><a class="markdownIt-Anchor" href="#map-接口"></a> Map 接口</h2>
<p>在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<h3 id="hashmap-和-hashtable-的区别"><a class="markdownIt-Anchor" href="#hashmap-和-hashtable-的区别"></a> HashMap 和 Hashtable 的区别</h3>
<div class="hljs code-wrapper"><pre><code>1. **线程是否安全：** `HashMap` 是非线程安全的，`HashTable` 是线程安全的,因为 `HashTable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；
2. **效率：** 因为线程安全的问题，`HashMap` 要比 `HashTable` 效率高一点。另外，`HashTable` 基本被淘汰，不要在代码中使用它；
3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。
4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
</code></pre></div>
<h3 id="hashmap-和-hashset-区别"><a class="markdownIt-Anchor" href="#hashmap-和-hashset-区别"></a> HashMap 和 HashSet 区别</h3>
<p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h3 id="hashmap-的长度为什么是-2-的幂次方"><a class="markdownIt-Anchor" href="#hashmap-的长度为什么是-2-的幂次方"></a> HashMap 的长度为什么是 2 的幂次方</h3>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h3 id="concurrenthashmap-和-hashtable-的区别"><a class="markdownIt-Anchor" href="#concurrenthashmap-和-hashtable-的区别"></a> ConcurrentHashMap 和 Hashtable 的区别</h3>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>
<p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
</li>
<li>
<p><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
<li>
<p><code>Hashtable</code>给所有数据加同一把锁，导致每次只能一个数据操作，<code>ConcurrentHashMap</code></p>
</li>
</ul>
<h1 id="杂"><a class="markdownIt-Anchor" href="#杂"></a> 杂</h1>
<h2 id="cookie和session"><a class="markdownIt-Anchor" href="#cookie和session"></a> Cookie和Session</h2>
<h3 id="什么是cooki"><a class="markdownIt-Anchor" href="#什么是cooki"></a> 什么是Cooki</h3>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="什么是session"><a class="markdownIt-Anchor" href="#什么是session"></a> 什么是Session</h3>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h3 id="cookie-和-session-有什么不同"><a class="markdownIt-Anchor" href="#cookie-和-session-有什么不同"></a> Cookie 和 Session 有什么不同？</h3>
<ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "kCmk4bWtyiEF1TyWkbzRJwoS-gzGzoHsz",
          app_key: "DyQhYPCkIBEgU0dNSnW90YM4",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/Hsueh-Xue" target="_blank" rel="nofollow noopener"><span>Hsueh-</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Hsueh-Xue" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        浙ICP备20005122号-1
      </a>
    </span>
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "https://cdn.jsdelivr.net/gh/Hsueh-Xue/Hsueh-Xue.github.io@master/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d41ced546e0d98131079f76f87dd8046";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
